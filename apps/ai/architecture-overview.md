# AI Proxy Architecture & Flow

## Mission

The `apps/ai` package exposes OpenAI/Anthropic-compatible endpoints that meter usage with Solana USDC by way of Coinbase's x402 facilitator. It runs on Bun + Hono, uses Drizzle ORM for Postgres access, and relies on SST-managed secrets for provider keys and database credentials.

## Server Pipeline

- **Entry Point** – `src/index.ts` instantiates a Hono app, adds `logger`, `cors`, and the global `errorHandler`, then mounts feature routers under `/v1/*`. The server listens on `config.port` (default 4000) and returns status metadata from `GET /`.
- **Auth Layer (`walletAuth`)** – `src/middleware/auth.ts` enforces the headers `x-wallet-address`, `x-wallet-signature`, and `x-wallet-nonce`. It decodes the signature with TweetNaCl and the supplied public key, rejects nonces older than 60 seconds, and stores the wallet address in context. Failures return `401` with a JSON error body.
- **Balance Gate (`balanceCheck`)** – `src/middleware/balance-check.ts` ensures a DB row exists for the wallet, then compares `balanceUsd` to `config.minBalance` (currently $0.50). If funds are low it responds with a `402` payload containing multiple x402 `PaymentRequirement` options (top-ups of 0.10, 1, 5, or 10 USD) generated by `createPaymentRequirements`.
- **Core Routes**
  - `/v1/models` (`src/routes/models.ts`) enumerates AI models and shows per-1M-token pricing after markup (`config.markup`, 15%).
  - `/v1/balance` (`src/routes/balance.ts`) reports the wallet's balance, totals, and recent activity timestamps.
  - `/v1/transactions` (`src/routes/transactions.ts`) returns recent transactions with token counts and post-transaction balances.
  - `/v1/topup` (`src/routes/topup.ts`) validates payment payloads, settles them via the facilitator, and credits the user's balance.
  - `/v1/chat/completions` (`src/routes/chat.ts`) dispatches by model prefix. Non-streaming responses call `deductCost` which runs a Drizzle transaction to subtract the computed cost and log a deduction row. Streaming responses pipe back text chunks and skip billing for now.
  - `/v1/completions` (`src/routes/completions.ts`) adapts OpenAI text completion requests into single-turn chat prompts, returning OpenAI-format JSON or SSE streams so SDK clients using `createOpenAICompatible` can connect without custom glue.

## Payment Orchestration

- **Requirement Generation** – `createPaymentRequirement(s)` (`src/services/x402-payment.ts`) normalizes the resource URL, sets the network (`solana-devnet`), devnet USDC mint, platform wallet, facilitator fee payer, and converts USD amounts to micro-USDC strings. `TOPUP_AMOUNTS` currently exports `[0.1, 1, 5, 10]` USD options.
- **Settlement** – `/v1/topup` performs structural validation (scheme/network/asset/payTo/resource host match, supported amount) and then POSTs `{ paymentPayload, paymentRequirements }` to `https://facilitator.payai.network/settle`. On success it updates balances, records a `topup` transaction, and writes a `payment_logs` entry keyed by transaction signature to block replays.
- **Data Integrity** – Both deductions and top-ups execute inside Drizzle transactions so balances and history stay consistent. Monetary values remain stringified with 8 decimal places to avoid float drift.

## Client & Test Harness

- **Wallet Adapter** – `SimpleWalletAdapter` in `test/test-client.ts` wraps the devnet test keypair and signs both legacy and versioned Solana transactions.
- **x402 Client** – `src/client/x402-client.ts` handles auth headers, payment creation, and automatic retry:
  - `createAuthHeaders` signs the current timestamp with the wallet's secret key, matching the server nonce policy.
  - `handlePaymentRequired` parses a 402 body, selects a valid requirement via `selectPaymentRequirements`, creates a signer with `svm.createSignerFromBase58`, generates a payment header (`createPaymentHeader`), posts it to `/v1/topup`, and replays the original request once credit is added.
- **CLI Flow** – Run `bun run test/test-client.ts "your prompt"` to exercise the full path: list models, fetch balance, attempt a chat (triggering auto top-up if needed), and inspect transactions. Logs display balances and deductions with 8 decimal precision.

## Security Snapshot

- **Current Controls**
  - Wallet-based authentication with short-lived nonces prevents unauthorized access without the private key.
  - Payment requests are fully validated: server checks requirement fields, trusts only facilitator-completed settlements, and blocks duplicate transaction signatures.
  - Database writes occur inside transactions to prevent race conditions on balances.
- **Hardening Opportunities**
  - Implement rate limiting per IP and per wallet to mitigate brute-force or spam attempts (highlighted as TODO in README).
  - Add request quotas, cooldowns after repeated failures, and richer logging/alerting on abnormal patterns.
  - Enforce request size and usage bounds to avoid resource exhaustion.
  - Consider caching or preflight guards to reduce load from repeated identical requests.

## Environment & Deployment

- `src/config.ts` currently pins `IS_DEVNET = true`, so the service points at devnet RPC, mint, and wallet. Secrets (`OpenAiApiKey`, `AnthropicApiKey`, `PlatformWallet`, `DatabaseUrl`) come from SST `Resource` bindings.
- To switch to mainnet, flip the `IS_DEVNET` flag (or refactor to env-based), update wallets/mints, and ensure the facilitator endpoint matches the target network.
- Drizzle migrations live in `drizzle/`; run them via `sst shell --stage <stage> -- drizzle-kit`. Utility scripts in `scripts/` support DB resets, facilitator debugging, and devnet wallet setup.

## Reference Snippets

```ts
// walletAuth (src/middleware/auth.ts)
const verified = nacl.sign.detached.verify(messageBytes, signatureBytes, publicKey);
if (!verified || Math.abs(Date.now() - Number(nonce)) > 60000) {
  return c.json({ error: "Invalid signature" }, 401);
}
```

```ts
// balanceCheck (src/middleware/balance-check.ts)
if (balance < config.minBalance) {
  const paymentRequirements = createPaymentRequirements(c.req.url, "Top-up required for API access");
  return c.json({ x402Version: 1, error: {...}, accepts: paymentRequirements }, 402);
}
```

```ts
// deductCost (src/services/balance-manager.ts)
const cost = calculateCost(model, usage, markup);
await tx.update(users)
  .set({ balanceUsd: newBalance.toFixed(8), totalSpent: (parseFloat(user.totalSpent) + cost).toFixed(8) })
  .where(eq(users.walletAddress, walletAddress));
await tx.insert(transactions).values({ type: "deduction", amountUsd: cost.toFixed(8), ... });
```

```ts
// topup settlement (src/routes/topup.ts)
const settlement = await settlePayment(paymentPayload, paymentRequirement);
if (!settlement.success) {
  return c.json({ error: "Payment settlement failed", reason: settlement.errorReason }, 400);
}
```

```ts
// client auto-payment (src/client/x402-client.ts)
const paymentHeader = await createPaymentHeader(signer, 1, requirement, {
  svmConfig: { rpcUrl: this.connection.rpcEndpoint },
});
const topupResponse = await fetch(topupUrl, {
  method: "POST",
  headers: { "Content-Type": "application/json", ...authHeaders },
  body: JSON.stringify({ paymentPayload, paymentRequirement: requirement }),
});
```
